1) Вариант 15. Напишите программу для генерации всех путей в лабиринте размером 5×5.
2) Описание алгоритма(на Python)
1.Создание лабиринта: лабиринт представлен в виде сетки 5×5, где каждая клетка является потенциальной позицией. Мы не храним саму карту лабиринта (предполагается, что все клетки открыты), а только трекер посещённых клеток.
В коде: maze = [...]
2. Отслеживание посещённых клеток: для избежания повторного захода в одни и те же клетки в начале функции find_all_paths() создаётся массив посещённых клеток visited. Этот массив помогает предотвратить замкнутые циклы и неоптимальные пути.
В коде: visited = [[False] * cols for _ in range(rows)]
3.Рекурсивный обход: алгоритм начинает поиск с начальной клетки (0,0) и рекурсивно исследует все возможные направления (вниз, вправо, вверх, влево). Для каждого направления проверяется, что соседняя клетка находится в пределах лабиринта и не была посещена ранее.
В коде: def dfs(r, c, path)
4. Маркировка посещённых клеток: когда мы посещаем клетку, мы отмечаем её как посещённую, чтобы не возвращаться в неё позже.
В коде: visited[r][c] = True
5. Обнаружение финала: когда мы приходим в финальную клетку (4,4), мы регистрируем текущий путь и возвращаемся обратно, чтобы продолжить исследование других маршрутов.
В коде: if r == rows - 1 and c == cols - 1:
6. Backtracking: после того как мы исследовали все возможные направления из текущей клетки, мы отменяем отметку о посещении (убираем маркер), чтобы вернуться назад и попробовать другие пути.
В коде: path.pop()//visited[r][c] = False 
3)Временная сложность: O(4^(n²)), где n — это размер лабиринта, в данном случае n=5.
4)Почему: В лабиринте n × n всего n² клеток. Из каждой клетки алгоритм пробует до 4 направлений (если нет стен и границ). В худшем случае (без стен) на каждом шаге есть ~4 варианта. Максимальная длина пути — не более n² шагов (нельзя посетить одну клетку дважды). Значит, глубина рекурсивного дерева — до n². На каждом уровне рекурсии до 4 ветвей. В худшем случае дерево имеет: 4^(n²) листьев (потенциальных путей).
5) 6. В чем суть алгоритма backtracking?
Backtracking — это метод решения задач путем систематического перебора всех возможных вариантов решения. Алгоритм строит решение пошагово и откатывается назад (backtrack), когда обнаруживает, что текущий путь не приведет к решению. Backtracking эффективен для задач, где нужно: найти все возможные решения (например, перестановки, комбинации) либо найти одно допустимое решение среди множества вариантов.
