АЛГОРИТМЫ СОРТИРОВКИ

СОРТИРОВКА ОБМЕНОМ (ПУЗЫРЬКОМ) (BUBBLE SORT)

def bubble_sort(arr):
    """
    Реализация алгоритма сортировки пузырьком.
    :param arr: Список, который надо отсортировать
    """
    n = len(arr)                        # Получаем длину списка
    for i in range(n):                  # Внешний цикл: проходим по списку n раз
        swapped = False                 # Флаг, используемый для оптимизации (рано заканчиваем, если список уже отсортирован)
        for j in range(0, n-i-1):       # Внутренний цикл: сравниваем соседние элементы
            if arr[j] > arr[j+1]:      # Если текущий элемент больше следующего
                arr[j], arr[j+1] = arr[j+1], arr[j]  # Меняем элементы местами
                swapped = True          # Ставим флаг в True, так как произошли перестановки
        if not swapped:                 # Если не было выполнено ни одной перестановки, список уже отсортирован
            break                       # Прерываем выполнение внешнего цикла
# Тестируем нашу функцию
if __name__ == "__main__":
    test_array = [64, 34, 25, 12, 22, 11, 90]
    print("Исходный массив:", test_array)
    bubble_sort(test_array)             # Применяем сортировку пузырьком
    print("Отсортированный массив:", test_array)

Исходный массив: [64, 34, 25, 12, 22, 11, 90]
Отсортированный массив: [11, 12, 22, 25, 34, 64, 90]

СОРТИРОВКА ВСТАВКАМИ (INSERTION SORT)
def insertion_sort(arr):
    """
    Реализует алгоритм сортировки вставками.
    Параметр arr: Список, который нужно отсортировать.
    Возвращает None, сортируя массив на месте.
    """
    # Цикл проходит по каждому элементу массива, начиная со второго
    for i in range(1, len(arr)):
        key = arr[i]                               # Берём текущий элемент
        j = i - 1                                  # Индекс предыдущего элемента
        # Двигаемся назад по отсортированной части массива,
        # сдвигая элементы вправо, пока не найдём правильную позицию для ключа
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]                   # Смещение большего элемента вправо
            j -= 1                                # Переход к предыдущему элементу 
        # Вставляем ключ в нужную позицию
        arr[j + 1] = key                          # Ключевое значение вставлено в правильное место
# Демонстрационный код
if __name__ == "__main__":
    example_list = [12, 11, 13, 5, 6]
    print("Исходный массив:", example_list)
    insertion_sort(example_list)                  # Выполняем сортировку
    print("Отсортированный массив:", example_list)

Исходный массив: [12, 11, 13, 5, 6]
Отсортированный массив: [5, 6, 11, 12, 13]

СОРТИРОВКА ШЕЛЛА (SHELLSORT)
def shell_sort(arr):
    """
    Реализует алгоритм сортировки Шелла.
    Параметр arr: Список, который нужно отсортировать.
    Возвращает None, так как сортировка осуществляется на месте.
    """
    gap = len(arr) // 2  # Изначальный интервал (шаг) берется как половина длины массива
    # Пока шаг больше нуля, выполняем сортировку с данным шагом
    while gap > 0:
        # Внешний цикл проходит по массиву, оставляя промежутки длиной gap
        for i in range(gap, len(arr)):  
            temp = arr[i]  # Сохраняем текущий элемент
            j = i
            # Внутренний цикл сдвигает элементы вперед, пока не найдется правильная позиция для temp
            while j >= gap and arr[j-gap] > temp:
                arr[j] = arr[j-gap]  # Передвигаем больший элемент вперед
                j -= gap  
            # Вставляем temp в подходящую позицию
            arr[j] = temp
        # Уменьшаем шаг вдвое для следующей итерации
        gap //= 2
# Демонстрационный код
if __name__ == "__main__":
    example_list = [12, 34, 54, 2, 3]
    print("Исходный массив:", example_list)
    shell_sort(example_list)  # Выполняем сортировку
    print("Отсортированный массив:", example_list)

Исходный массив: [12, 34, 54, 2, 3]
Отсортированный массив: [2, 3, 12, 34, 54]

БЫСТРАЯ СОРТИРОВКА (QUICK SORT)

def quicksort(arr):
    """
    Реализует алгоритм быстрой сортировки (quicksort).
    Параметры:
    arr - список, который нужно отсортировать.
    Возвращает отсортированный список.
    """
    if len(arr) <= 1:                              # Базовый случай: пустой или одноэлементный список считается отсортированным
        return arr
    pivot = arr[len(arr) // 2]                     # Выбор опорного элемента (pivot), середина массива
    left = [x for x in arr if x < pivot]           # Все элементы меньше опорного отправляются влево
    middle = [x for x in arr if x == pivot]        # Элементы, равные опорному, идут в центр
    right = [x for x in arr if x > pivot]          # Большие элементы отправляем вправо  
    return quicksort(left) + middle + quicksort(right)  # Рекурсивно сортируем левую и правую части и объединяем их
# Пример использования
if __name__ == "__main__":
    unsorted_list = [3, 6, 8, 10, 1, 2, 1]
    sorted_list = quicksort(unsorted_list)
    print(f'Исходный массив: {unsorted_list}')
    print(f'Отсортированный массив: {sorted_list}')

Исходный массив: [3, 6, 8, 10, 1, 2, 1]
Отсортированный массив: [1, 1, 2, 3, 6, 8, 10]

АЛГОРИТМЫ ПОИСКА

ПОСЛЕДОВАТЕЛЬНЫЙ (ЛИНЕЙНЫЙ) ПОИСК

def linear_search(arr, target):
    """
    Реализует алгоритм линейного поиска.
    Параметры:
    arr - список, в котором ведётся поиск.
    target - искомое значение.
    Возвращает индекс найденного элемента или -1, если элемент не найден.
    """
    for index, value in enumerate(arr):  # Перебираем индексы и значения элементов списка
        if value == target:              # Если текущий элемент соответствует целевому
            return index                 # Возвращаем индекс найденного элемента
    return -1                           # Если элемент не найден, возвращаем -1
# Демонстрация работы функции
if __name__ == "__main__":
    my_list = [4, 2, 7, 1, 9, 3]
    search_value = 7
    result = linear_search(my_list, search_value)
    if result != -1:
        print(f'Значение {search_value} найдено на индексе {result}.')
    else:
        print(f'Значение {search_value} не найдено.')

Значение 7 найдено на индексе 2.

ПОИСК ПО ФИБОНАЧЧИ

def fibonacci_search(arr, target):
    """
    Реализует алгоритм поиска по Фибоначчи.
    Параметры:
    arr - отсортированный массив, в котором ведется поиск.
    target - искомое значение.
    Возвращает индекс найденного элемента или -1, если элемент не найден.
    """
    def fib_m(m):
        """Генерируем m-е число Фибоначчи."""
        if m == 0 or m == 1:
            return m
        f_minus_2 = 0
        f_minus_1 = 1
        current_fib = f_minus_1 + f_minus_2
        count = 2
        while count <= m:
            f_minus_2 = f_minus_1
            f_minus_1 = current_fib
            current_fib = f_minus_1 + f_minus_2
            count += 1
        return current_fib
    # Находим минимальное число Фибоначчи, большее или равное размеру массива
    n = len(arr)
    m = 0
    while fib_m(m) < n:
        m += 1
    # Переменные для отслеживания индексов
    offset = -1
    fib_minus_2 = fib_m(m - 2)
    fib_minus_1 = fib_m(m - 1)
    # Сам поиск
    while fib_minus_1 > 1:
        i = min(offset + fib_minus_2, n - 1)  # Ограничиваем индекс пределами массива
        if arr[i] < target:
            # Если элемент меньше цели, идём вправо
            fib_minus_1, fib_minus_2 = fib_minus_2, fib_minus_1 - fib_minus_2
            offset = i
        elif arr[i] > target:
            # Если элемент больше цели, идём влево
            fib_minus_1, fib_minus_2 = fib_minus_2, fib_minus_2 - fib_minus_1
        else:
            # Нашли точное совпадение
            return i
    # Дополнительная проверка последней возможной позиции
    if fib_minus_2 and arr[offset + 1] == target:
        return offset + 1
    # Если элемент не найден
    return -1
# Пример использования
if __name__ == "__main__":
    arr = [10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100]
    target = 90
    result = fibonacci_search(arr, target)
    if result != -1:
        print(f"Элемент {target} найден на позиции {result}")
    else:
        print(f"Элемент {target} не найден.")

Элемент 90 найден на позиции 9
