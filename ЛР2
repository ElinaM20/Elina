1)Мультисписок (вложенный список)
- это структура, каждый элемент которой входит более чем в один список одновременно и имеет соответствующее числу списков количество полей связи.
В Python для создания мультисписка достаточно включить списки в список. При доступе к элементам используются индексы по обоим направлениям: первый индекс указывает на строку, второй — на столбец. Также доступен широкий спектр операций над списками, включая конкатенацию, нарезку и прочие полезные методы. Метод append добавляет элемент, del - удаляет.
В C++ мультисписок удобно реализовать с помощью контейнера std::vector<std::vector<T>>, где каждый внутренний вектор представляет собой список элементов. Это позволяет легко управлять элементами и производить операции, характерные для контейнеров STL. Альтернативно можно использовать массив массивов, но это менее гибко и накладывает ограничение на статичность размеров. Метод push_back добавляет элемент, erase - удаляет.
В Java мультисписок можно реализовать с помощью коллекции List<List<T>>, где внутренний список хранит элементы, а внешний список выступает как контейнер строк. Доступ к элементам также осуществляется через двойной индекс: первый индекс указывает на строку, второй — на столбец. Встроенные средства Java предоставляют удобные методы для манипуляций с элементами, добавлением и удалением. Метод add добавляет элемент, remove - удаляет, set - изменяет.

2)Очередь
- это структура данных, которая работает по принципу FIFO (First In, First Out) — «первый пришёл — первый вышел», элементы добавляются в конец структуры и извлекаются из начала.
Чтобы реализовать очередь в Python, нужно создать класс и инициализировать его пустым списком. Это реализуется с помощью модуль queue. Этот модуль предоставляет многопоточную очередь, которая синхронизирована и безопасна для использования в многопоточных программах. Методы put() добавляют элемент в конец очереди, а get() извлекают элемент из начала.
В C++ очередь обычно реализуется с помощью контейнера std::queue из стандартной библиотеки STL. Этот контейнер реализует очередь на основе адаптивного контейнера (например, std::deque или std::list), обеспечивая эффективные операции добавления (push) и извлечения (pop) элементов.
В Java очередь реализуется с помощью интерфейса Queue, который поддерживается классом LinkedList: двусторонняя очередь, которая может выступать как простая очередь с эффективной поддержкой операций вставки и удаления. Основными операциями являются: offer(e) - добавляет элемент в конец очереди; poll() - извлекает и удаляет элемент из начала очереди; peek() - возвращает элемент из начала очереди, не удаляя его.

3)Дек(двунаправленная очередь)
- это универсальная структура данных, которая представляет собой последовательность элементов, у которой есть два конца; добавление и удаление элементов может происходить как в начало, так и в конец структуры. 
В Python дек реализуется с помощью класса collections.deque. Этот класс предоставляет высокопроизводительную реализацию двусторонней очереди, поддерживающей эффективные операции добавления и удаления элементов с обоих концов. Добавление элементов в конец и начало: append() и appendleft(), удаление элементов с конца и начала: pop() и popleft().
В C++ дек реализуется с помощью контейнера std::deque из стандартной библиотеки STL. Этот контейнер поддерживает эффективные операции вставки и удаления элементов как с начала, так и с конца. std::deque предоставляет методы для доступа к первому и последнему элементам, а также специальные операции для вставки и удаления элементов с обоих концов. Добавление элементов в конец и начало: push_back() и push_front(), удаление элементов с конца и начала: pop_back() и pop_front().
В Java дек реализуется с помощью интерфейса Deque, который поддерживает двустороннюю очередь. Одна из наиболее популярных реализаций — это класс ArrayDeque, который предоставляет эффективную реализацию двусторонней очереди. ArrayDeque поддерживает все операции, необходимые для работы с деком, такие как добавление и удаление элементов с начала и конца, а также получение первого и последнего элементов. Добавление элементов в конец и начало: addLast() и addFirst(), удаление элементов с конца и начала: removeLast() и removeFirst().

4)Приоритетная очередь
- структура данных, где порядок обработки элементов определяется не временем добавления, а их «важностью» (приоритетом); в отличие от обычной очереди, элементы удаляются на основе приоритета, а не по правилу «первый вход — первый выход» (FIFO).
В Python приоритетная очередь реализуется с помощью модуля queue, конкретно класса PriorityQueue. Этот класс предоставляет безопасную для многопоточной среды реализацию очереди, где элементы извлекаются в порядке приоритета. Приоритет устанавливается специальным образом, чаще всего через значение элемента (например, числом), при этом элементы с наименьшими значениями извлекаются первыми. Другая популярная реализация — это использование модуля heapq, который реализует очередь на основе бинарной кучи. В отличие от PriorityQueue, heapq не является потоко-безопасным, зато обеспечивает высокую производительность. Метод put либо heappush(если используется модуль heapq) добавляет элемент, pop или heappop(если используется модуль heapq) - удаляет.
В C++ приоритетная очередь реализуется с помощью класса-шаблона std::priority_queue из стандартной библиотеки STL. Этот класс автоматически организует элементы в порядке приоритета (по умолчанию элементы с наибольшими значениями имеют высший приоритет). За кулисами он использует бинарную кучу, что обеспечивает логарифмическое время вставки и извлечения элементов. При желании можно изменить критерий сортировки, установив свой компаратор, чтобы контролировать порядок приоритетов. Метод put добавляет элемент, pop - удаляет.
В Java приоритетная очередь реализуется с помощью класса PriorityQueue. Этот класс обеспечивает эффективную реализацию очереди с приоритетами, где элементы извлекаются в порядке возрастания их естественного порядка (или в порядке, установленном пользователем с помощью компаратора).  При создании экземпляра PriorityQueue можно передать компаратор, который будет устанавливать порядок элементов в очереди. Это позволяет настраивать критерии приоритета под конкретные нужды. Метод offer либо add добавляет элемент, poll - удаляет.
