**Дерево** — это иерархическая структура данных, состоящая из узлов, где каждый узел имеет один родительский узел и может иметь несколько дочерних узлов.  

**Граф**  — это структура данных, состоящая из вершин (узлов) и рёбер (связей между ними). Формально граф можно представить как пару (V, E), где: V — множество вершин; E — множество рёбер (дуг, связей). Графы могут быть ориентированными (ребра имеют направление) и неориентированными (ребра симметричны); могут содержать циклы.

**Реализация деревьев:**

В Python деревья часто реализуются через классы, где каждый узел — отдельный объект. Узел дерева (Node) содержит значение и ссылки на дочерние узлы. Для бинарного дерева каждый узел имеет два потомка (left и right), а для произвольного дерева — список или словарь дочерних узлов. Способы организации связей: прямое хранение ссылок(каждый узел хранит прямые ссылки (left, right) на своих потомков, что обеспечивает простоту реализации и доступа к детям); список детей(для деревьев с переменным числом потомков узел содержит список ссылок на всех своих детей, что обеспечивает гибкость при добавлении/удалении ветвей).

В C++ деревья реализуются через структуры или классы с использованием указателей. Узел (TreeNode) содержит значение и указатели на левого и правого потомков. Управление памятью осуществляется вручную. Указатели на дочерние узлы: в бинарном дереве — left и right типа Node*, а для произвольных деревьев — динамический массив указателей или список (std::vector<Node*>, std::list<Node*>). Способы организации связей: указатели(узлы связаны через указатели (Node*), что позволяет динамически выделять память и обеспечивает прямой доступ к потомкам через разыменование указателя); векторы указателей(для произвольных деревьев: std::vector<Node*> хранит все дочерние узлы, обеспечивает удобство при итерации по детям и автоматическое управление размером); ручное управление памятью(память для узлов выделяется через new, освобождается через delete, возможность использования умных указателей (std::unique_ptr, std::shared_ptr) для автоматического управления).

В Java деревья реализуются через классы с явной типизацией. Узел (TreeNode) содержит значение и ссылки на дочерние узлы. Для бинарного дерева используются left и right, для произвольного — список детей. Структура узла строго определена. Способы организации связей: поля‑ссылки(в бинарном дереве каждый узел имеет два поля‑указателя на левого и правого ребёнка); коллекции для детей(для деревьев с произвольным числом потомков используется List, Set или массив, позволяет динамически управлять числом дочерних узлов).

**Реализация графов:**

В Python графы часто реализуются через словари или списки. Наиболее распространённый подход — использование списков смежности, где каждая вершина связана со списком смежных вершин. 1-Словарь списков: каждая вершина — ключ словаря; значение по ключу — список смежных вершин; легко добавлять новые вершины и рёбра: достаточно дописать элемент в словарь и обновить список соседей; подходит для разреженных графов и динамических сценариев, где структура часто меняется. 2-Матрица смежности: двумерный список (список списков), где элемент [i][j] указывает на наличие ребра между вершинами i и j; удобна для плотных графов, когда почти все вершины связаны друг с другом; проверка наличия ребра выполняется за константное время, но расход памяти выше. 3-Использование внешних библиотек: networkx — богатый набор алгоритмов (поиск путей, компоненты связности, центральность и др.) и инструментов визуализации; igraph — оптимизирован для работы с большими графами, высокая производительность.

В C++ графы реализуются с использованием векторов, списков или матриц. Часто применяется представление в виде списков смежности с использованием указателей или векторов. 1-Вектор векторов(std::vector<std::vector<T>>): аналогичен Java‑ArrayList: динамические массивы для списка смежности; быстрый произвольный доступ; эффективное использование памяти; подходит для большинства сценариев, включая динамическое добавление рёбер. 2-Списки смежности через std::list или std::forward_list: используются, если нужны частые вставки/удаления в середине списка; менее эффективны для случайного доступа, но лучше для модификаций в произвольных позициях. 3-Матрица смежности: двумерный вектор (std::vector<std::vector<bool>>) или статический массив; обеспечивает O(1)‑проверку смежности, но занимает O(V²) памяти; рекомендована для плотных графов и алгоритмов, требующих частых проверок связей. 4-Ручные структуры с указателями: узлы графа реализуются как структуры с полями‑указателями на соседей; даёт максимальный контроль над памятью и производительностью, но повышает риск ошибок (утечки, висячие указатели).

В Java графы реализуются с использованием коллекций, таких как ArrayList или HashMap. Часто применяется представление в виде списков смежности. 1-Список смежности через ArrayList:  создаётся массив (или список) списков: индекс соответствует номеру вершины, а содержимое — список смежных вершин; компилятор контролирует типы данных, снижая риск ошибок; эффективен для разреженных графов, экономит память. 2-HashMap для гибких ключей: если вершины обозначаются не числами, а строками или объектами, используют HashMap<KeyType, List<KeyType>>; позволяет легко менять идентификаторы вершин без переиндексации. 3-Матрица смежности (int[][] или boolean[][]): двумерный массив, где matrix[i][j] == true означает наличие ребра; быстрый доступ к информации о смежности (O(1)), но требует O(V²) памяти; оптимален для плотных графов с частыми проверками связей.

*Также с помощью Алгоритма Дейкстры во всех трех языках программирования можно найти кратчайший путь от стартовой вершины ко всем остальным в графе с неотрицательными весами рёбер. Реализуется поверх структуры графа (которая может быть деревом, но чаще — общий граф).

    
**Поиск пути от корневого узла до заданного узла дерева с помощью алгоритма обхода в глубину (DFS).** Ключевая идея: начинаем с заданной вершины (узла) и идём «как можно глубже» по одному пути. Только когда дальше идти некуда (достигли листа или непосещённой вершины), возвращаемся на шаг назад («backtracking») и пробуем другой путь.

**На Python:**
1)Структура данных класс Node: каждый узел дерева представлен объектом класса Node: value — хранимое значение, children — список дочерних узлов, add_child() — метод для добавления потомка в список children.

2)Основная функция: find_path(root, target) ищет путь от корня (root) до узла со значением target и возвращает список значений узлов на пути (например, ['A', 'B', 'E']) или None, если путь не найден. 

3)Вспомогательная функция: dfs_find_path(node, target, path) - это рекурсивный обход в глубину (Depth‑First Search, DFS) с обратной трассировкой (backtracking). Шаги алгоритма: 1-Проверка на пустой узел: если node is None, возвращаем False (достигли «конца» ветви, путь не найден). 2-Добавление текущего узла в путь: path.append(node.value) — фиксируем, что мы зашли в этот узел. 3-Проверка, является ли узел целевым: если node.value == target, возвращаем True (цель достигнута, путь найден). 4-Рекурсивный обход дочерних узлов: для каждого потомка child в node.children: вызываем dfs_find_path(child, target, path) и, если функция вернула True, значит, в поддереве child найден целевой узел, возвращаем True, чтобы прекратить дальнейший поиск. 4-Обратная трассировка (backtracking): если ни один потомок не привёл к цели: path.pop() — удаляем текущий узел из пути (мы зашли в тупик) и возвращаем False (продолжаем поиск в других ветвях).

   
**На C++:**
1)Структура узла дерева struct BTree: data — хранимое значение (целое число), left и right — указатели на левое и правое поддеревья (NULL означает отсутствие потомка).

2)Вставка в BST (insert): если текущий узел NULL (достигли «пустого» места), создаём новый узел через add(key); если key < node->data — вставляем в левое поддерево; если key >= node->data — в правое поддерево (дубликаты идут вправо). Всегда возвращается текущий узел, чтобы сохранить связь в дереве.

3)Поиск пути getPathFromRootToNode(рекурсия, через которую неявно реализован backtracking): 1-Проверка на конец ветки: если node == NULL, возвращаем пустой вектор ({}). 2-Найден целевой узел: если node->data == key, возвращаем вектор с одним элементом ({node->data}). 3-Поиск в левом поддереве: рекурсивно вызываем функцию для node->left, если путь найден (!leftPath.empty()), добавляем текущее значение node->data в начало пути (insert). 4-Поиск в правом поддереве-аналогично левому.

   
**На Java:**
1)Структура данных TreeNode: внутренний класс описывает узел бинарного дерева: val — значение узла (целое число), left, right — ссылки на левого и правого потомков (null, если потомка нет).

2)Основной метод public boolean hasPathSum(TreeNode root, int targetSum): принимает корень дерева и целевую сумму; запускает рекурсивный поиск, передавая начальную сумму 0; возвращает true, если такой путь существует, иначе false.

3)Рекурсивный метод hasPathSumRecursive: 1-Базовый случай: пустой узел(если дошли до null (конца ветви), путь не завершён — возвращаем false). 2-Обновление текущей суммы currentSum += root.val: добавляем значение текущего узла к сумме пути. 3-Проверка, является ли узел листом boolean isLeaf = (root.left == null && root.right == null). 4-Успешное условие if (isLeaf && currentSum == targetSum) return true: если узел лист и сумма совпадает с targetSum — путь найден. 5-Рекурсивный поиск в поддеревьях boolean leftHasPath = hasPathSumRecursive(root.left, targetSum, currentSum);// boolean rightHasPath = hasPathSumRecursive(root.right, targetSum, currentSum): ищем путь в левом и правом поддеревьях, текущая сумма (currentSum) передаётся дальше — она уже включает значение текущего узла. 6-Возврат результата return leftHasPath || rightHasPath: если путь найден хотя бы в одном поддереве — возвращаем true, иначе — false.

Данный алгоритм не использует backtracking в классическом понимании (без явного «отката» изменений). Вместо этого он: полагается на передачу параметров по значению (каждая ветвь получает свою копию currentSum) и использует механизм стека вызовов для автоматического управления состоянием.

     
**Временная сложность:** O(N), где N — количество узлов в дереве, потому что алгоритм реализует DFS (поиск в глубину). В DFS каждый узел посещается ровно один раз. На каждом узле выполняется O(1) работы (без учёта рекурсивных вызовов). Суммарная работа: O(1) × N = O(N).
