Дерево — это иерархическая структура данных, состоящая из узлов, где каждый узел имеет один родительский узел и может иметь несколько дочерних узлов.


Граф  — это структура данных, состоящая из вершин (узлов) и рёбер (связей между ними). Формально граф можно представить как пару (V, E), где: V — множество вершин; E — множество рёбер (дуг, связей). Графы могут быть ориентированными (ребра имеют направление) и неориентированными (ребра симметричны); могут содержать циклы.


В Python деревья часто реализуются через классы, где каждый узел — отдельный объект. Узел дерева (Node) содержит значение и ссылки на дочерние узлы. Для бинарного дерева каждый узел имеет два потомка (left и right), а для произвольного дерева — список или словарь дочерних узлов. Способы организации связей: прямое хранение ссылок(каждый узел хранит прямые ссылки (left, right) на своих потомков, что обеспечивает простоту реализации и доступа к детям); список детей(для деревьев с переменным числом потомков узел содержит список ссылок на всех своих детей, что обеспечивает гибкость при добавлении/удалении ветвей).

В C++ деревья реализуются через структуры или классы с использованием указателей. Узел (TreeNode) содержит значение и указатели на левого и правого потомков. Управление памятью осуществляется вручную. Указатели на дочерние узлы: в бинарном дереве — left и right типа Node*, а для произвольных деревьев — динамический массив указателей или список (std::vector<Node*>, std::list<Node*>). Способы организации связей: указатели(узлы связаны через указатели (Node*), что позволяет динамически выделять память и обеспечивает прямой доступ к потомкам через разыменование указателя); векторы указателей(для произвольных деревьев: std::vector<Node*> хранит все дочерние узлы, обеспечивает удобство при итерации по детям и автоматическое управление размером); ручное управление памятью(память для узлов выделяется через new, освобождается через delete, возможность использования умных указателей (std::unique_ptr, std::shared_ptr) для автоматического управления).

В Java деревья реализуются через классы с явной типизацией. Узел (TreeNode) содержит значение и ссылки на дочерние узлы. Для бинарного дерева используются left и right, для произвольного — список детей. Структура узла строго определена. Способы организации связей: поля‑ссылки(в бинарном дереве каждый узел имеет два поля‑указателя на левого и правого ребёнка); коллекции для детей(для деревьев с произвольным числом потомков используется List, Set или массив, позволяет динамически управлять числом дочерних узлов).


В Python графы часто реализуются через словари или списки. Наиболее распространённый подход — использование списков смежности, где каждая вершина связана со списком смежных вершин. 1-Словарь списков: каждая вершина — ключ словаря; значение по ключу — список смежных вершин; легко добавлять новые вершины и рёбра: достаточно дописать элемент в словарь и обновить список соседей; подходит для разреженных графов и динамических сценариев, где структура часто меняется. 2-Матрица смежности: двумерный список (список списков), где элемент [i][j] указывает на наличие ребра между вершинами i и j; удобна для плотных графов, когда почти все вершины связаны друг с другом; проверка наличия ребра выполняется за константное время, но расход памяти выше. 3-Использование внешних библиотек: networkx — богатый набор алгоритмов (поиск путей, компоненты связности, центральность и др.) и инструментов визуализации; igraph — оптимизирован для работы с большими графами, высокая производительность.

В C++ графы реализуются с использованием векторов, списков или матриц. Часто применяется представление в виде списков смежности с использованием указателей или векторов. 1-Вектор векторов(std::vector<std::vector<T>>): аналогичен Java‑ArrayList: динамические массивы для списка смежности; быстрый произвольный доступ; эффективное использование памяти; подходит для большинства сценариев, включая динамическое добавление рёбер. 2-Списки смежности через std::list или std::forward_list: используются, если нужны частые вставки/удаления в середине списка; менее эффективны для случайного доступа, но лучше для модификаций в произвольных позициях. 3-Матрица смежности: двумерный вектор (std::vector<std::vector<bool>>) или статический массив; обеспечивает O(1)‑проверку смежности, но занимает O(V²) памяти; рекомендована для плотных графов и алгоритмов, требующих частых проверок связей. 4-Ручные структуры с указателями: узлы графа реализуются как структуры с полями‑указателями на соседей; даёт максимальный контроль над памятью и производительностью, но повышает риск ошибок (утечки, висячие указатели).

В Java графы реализуются с использованием коллекций, таких как ArrayList или HashMap. Часто применяется представление в виде списков смежности. 1-Список смежности через ArrayList:  создаётся массив (или список) списков: индекс соответствует номеру вершины, а содержимое — список смежных вершин; компилятор контролирует типы данных, снижая риск ошибок; эффективен для разреженных графов, экономит память. 2-HashMap для гибких ключей: если вершины обозначаются не числами, а строками или объектами, используют HashMap<KeyType, List<KeyType>>; позволяет легко менять идентификаторы вершин без переиндексации. 3-Матрица смежности (int[][] или boolean[][]): двумерный массив, где matrix[i][j] == true означает наличие ребра; быстрый доступ к информации о смежности (O(1)), но требует O(V²) памяти; оптимален для плотных графов с частыми проверками связей.
С помощью Алгоритма Дейкстры во всех трех языках программирования можно найти кратчайший путь от стартовой вершины ко всем остальным в графе с неотрицательными весами рёбер. Реализуется поверх структуры графа (которая может быть деревом, но чаще — общий граф).


Алгоритм обход в глубину (DFS) для поиска пути от корневого узла до заданного узла дерева.
На Python:
1)Основная функция: find_path(root, target) ищет путь от корня (root) до узла со значением target и возвращает список значений узлов на пути (например, ['A', 'B', 'E']) или None, если путь не найден. 2)Вспомогательная функция: dfs_find_path(node, target, path) - это рекурсивный обход в глубину (Depth‑First Search, DFS) с обратной трассировкой (backtracking). Шаги алгоритма: 1-Проверка на пустой узел: если node is None, возвращаем False (достигли «конца» ветви, путь не найден). 2-Добавление текущего узла в путь: path.append(node.value) — фиксируем, что мы зашли в этот узел. 3-Проверка, является ли узел целевым: если node.value == target, возвращаем True (цель достигнута, путь найден). 4-Рекурсивный обход дочерних узлов: для каждого потомка child в node.children: вызываем dfs_find_path(child, target, path) и, если функция вернула True, значит, в поддереве child найден целевой узел, возвращаем True, чтобы прекратить дальнейший поиск. 4-Обратная трассировка (backtracking): если ни один потомок не привёл к цели: path.pop() — удаляем текущий узел из пути (мы зашли в тупик) и возвращаем False (продолжаем поиск в других ветвях).
