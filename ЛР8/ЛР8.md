1)Вариант 12. Поиск с имитацией отжига для раскраски графа
Задача: реализовать имитацию отжига для задачи раскраски графа с минимизацией числа
цветов.
Требования:
- Входные данные: неориентированный граф
- Выход: раскраска вершин и количество использованных цветов
- Вывести текущее число конфликтов при понижении температуры
Входные данные:
Граф с 10 вершинами и 15 ребрами

2)Описание алгоритма
  1)Инициализация (__init__): задаются число вершин и список рёбер, строится список смежности (adj_list) для быстрого доступа к соседям каждой вершины.
  2)Подсчёт конфликтов (count_conflicts): проходит по всем рёбрам и считает, сколько пар смежных вершин имеют одинаковый цвет (конфликты).
  3)Генерация соседнего решения (generate_neighbor): случайно выбирается одна вершина, собираются цвета её соседей, выбирается новый цвет для вершины: если есть свободные цвета (не используемые соседями) — берётся случайный из них; иначе — добавляется новый цвет (на единицу больше максимального текущего).
  4)Имитация отжига (simulated_annealing):
  Начальное решение: каждая вершина получает свой уникальный цвет (гарантирует отсутствие конфликтов, но использует много цветов).
  Основной цикл(while temp > min_temp) на каждой итерации: генерируется соседнее решение (generate_neighbor); считаются конфликты в новом решении; вычисляется delta — изменение числа конфликтов; применяется критерий Метрополиса; обновляется лучшее решение, если текущее лучше сохранённого; температура понижается: temp *= cooling_rate; возвращается лучшее найденное решение и число конфликтов.
  5)Подсчёт цветов (get_num_colors): считает число уникальных цветов в раскраске (через set).
  
3)Временная сложность: O(K · (M + N))), где: N — число вершин графа (num_vertices); M — число рёбер графа (len(edges)); K — общее число итераций в цикле имитации отжига. Для данной задачи (N = 10, M = 15, фиксированные параметры охлаждения): все операции выполняются за константное время → O(1).

4)Почему: K — общее число итераций цикла имитации отжига (зависит от параметров охлаждения: начальная/конечная температура, скорость охлаждения). На каждой итерации выполняются две ключевые операции: count_conflicts() — проходит по всем рёбрам: O(M); generate_neighbor() — обрабатывает соседей вершины и цвета: в худшем случае O(N). Итого за одну итерацию: O(M + N). За все K итераций: O(K · (M + N)).

5) 12. Критерий Метрополиса. Какова формула критерия Метрополиса в алгоритме имитации отжига и что она означает?
В алгоритме имитации отжига критерий Метрополиса задаётся формулой: P(принять) = exp(-ΔE / T), где: P(принять) — вероятность принятия нового (худшего) решения; ΔE=E(новое)−E(текущее) — изменение «энергии» (значения целевой функции); T — текущая температура в алгоритме (уменьшается со временем).
Что означает: если новое решение лучше (ΔE<0), оно принимается гарантированно. Если новое решение хуже (ΔE≥0), оно принимается с вероятностью P(принять), которая: тем меньше, чем сильнее ухудшение (ΔE); тем больше, чем выше температура (T).
Суть: на ранних этапах (при высокой T) алгоритм охотно принимает ухудшения — это помогает «выбраться» из локальных минимумов. На поздних этапах (при низкой T) он почти не идёт на уступки — «закрепляется» в найденном хорошем решении. Критерий Метрополиса позволяет: избегать застревания в локальных минимумах за счёт временного принятия худших решений; асимптотически сходиться к глобальному оптимуму при правильном охлаждении; сбалансировать исследование и эксплуатацию: в начале — широкий поиск по пространству решений; в конце — точная настройка лучшего найденного решения.
