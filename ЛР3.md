1)Бинарная куча
- это полное двоичное дерево, в котором все уровни, кроме последнего, полностью заполнены; последний уровень заполняется слева направо; соблюдается свойство упорядочения: значение каждого узла либо не меньше (max‑heap), либо не больше (min‑heap) значений его потомков.
В Python для создания бинарной кучи используется список+модуль heapq, где родительский элемент всегда меньше или равен дочерним. Также можно реализовать бинарную кучу в виде собственного класса. Пользователь не видит дерево: список выглядит как плоский массив, но семантически это куча. Функция heappush(list, item) — добавляет элемент, heappop(list) — удаляет и возвращает минимальный элемент.
В C++ реализуется через std::priority_queue или std::vector. Функция push — добавляет элемент, pop — удаляет элемент.
В Java реализуется классом PriorityQueue, который использует внутренний массив. Нет прямого доступа к внутреннему массиву; все операции через API очереди. Функция add(item) / offer(item) — вставка элемента, peek() — просмотр корня без удаления, poll() — извлечение и удаление корня.

2)Биноминальная куча
- это структура данных, реализующая абстрактный тип «очередь с приоритетом». Она состоит из набора биномиальных деревьев, где каждое дерево соответствует определённому свойству: ключ каждой вершины не меньше ключа её родителя, и все биномиальные деревья имеют разный размер.
В стандартной библиотеке Python нет встроенной реализации биномиальной кучи. Обычно её реализуют вручную, используя классы для узлов и самой кучи BinomialHeap. Пример включает создание узлов, операции слияния деревьев и управления списком корней. Меоды: insert(key)-создаёт новый узел с заданным ключом и формирует из него биномиальное дерево степени 0; getMin()-проходит по списку корней и находит узел с минимальным ключом; merge(heap1, heap2)-объединяет два списка корней, сортируя их по возрастанию степеней.
В C++ также нет стандартной реализации в STL. Требуется ручная реализация с использованием структур BinomialHeap для узлов и методов для операций над кучей. Методы: insert(int key)-создаёт узел; getMin()-проходит по списку корней, ищет минимум; extractMin()-находит и удаляет минимальный корень, детей удалённого корня добавляет в список; merge(BinomialHeap& other)-сливает два списка корней, объединяет деревья одинаковой степени; decreaseKey(BinomialNode* node, int new_key)-обновляет ключ, поднимает узел при нарушении свойства кучи. Операции реализованы как методы, работающие с указателями и перестройкой связей.
В Java стандартной реализации тоже нет. Обычно используют классы для узлов (BinomialHeapNode) и самой кучи (BinomialHeap), реализуя методы для основных операций. Управление памятью происходит через сборщик мусора, подход - объектно‑ориентированный (публичные/приватные поля). Основные операторы аналогичны Python и C++, но с синтаксисом Java: insert(int key), getMin(), extractMin(), merge(BinomialHeap other), decreaseKey(BinomialNode node, int new_key), delete(BinomialNode node)

3)Куча Фибоначчи
— это структура данных для реализации очереди с приоритетом, состоящая из набора деревьев произвольной формы (не обязательно биномиальных), которые удовлетворяют свойству кучи: ключ родителя ≤ ключей детей (для min‑heap); организованы в циклический двусвязный список корней; поддерживают отложенные операции (например, объединение деревьев откладывается до необходимости).
В Python она реализуется через классы FibonacciNode и FibonacciHeap. Встроенной реализации нет — пишут вручную; управление памятью происходит через сборщик мусора Python. В алгоритме для печати ряда Фибоначчи до заданного количества элементов: цикл for выполняется ровно n раз (от 0 до n – 1) и на каждой итерации печатает текущее число Фибоначчи и обновляет переменные. В алгоритме для рекурсивного вычисления n-го числа ряда Фибоначчи: рекурсивный вызов вычисляет предыдущее и предпредыдущее числа Фибоначчи и возвращает их сумму.
В C++ реализуется через структуру Node и класс FibonacciHeap.
В Java реализуется через классы FibonacciNode и FibonacciHeap

4)Хеш-таблица
