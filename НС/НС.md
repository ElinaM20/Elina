1)Задание 14: Neural Style Transfer
Задача: реализовать Neural Style Transfer для применения стиля одного
изображения к другому.
Требования:
Использовать VGG19 как feature extractor
Gram matrix для стиля
Content loss и Style loss
Оптимизация изображения через gradient descent
Код-заготовка (Python):
import tensorflow as tf
class NeuralStyleTransfer:
 def __init__(self, content_layers, style_layers):
 self.content_layers = content_layers
 self.style_layers = style_layers

 # TODO: Загрузить VGG19
 # self.model = tf.keras.applications.VGG19(include_top=False,
weights='imagenet')
 # Установить trainable=False

 # TODO: Создать style transfer модель
 # которая возвращает content и style features

 def gram_matrix(self, tensor):
 # TODO: Вычислить Gram matrix
 # 1. Получить shape: (height, width, channels)
 # 2. Reshape в (height*width, channels)
 # 3. Вычислить матрицу корреляции: G = X @ X^T
 # 4. Нормализовать
 pass

 def content_loss(self, content_features, generated_features):
 # TODO: Вычислить content loss (MSE)
 # Сравнивает feature maps оригинального и сгенерированного изображения
 pass

 def style_loss(self, style_features, generated_features):
 # TODO: Вычислить style loss
57
 # Сравнивает Gram matrices
 total_loss = 0
 for style_feat, gen_feat in zip(style_features, generated_features):
 style_gram = self.gram_matrix(style_feat)
 gen_gram = self.gram_matrix(gen_feat)
 total_loss += tf.reduce_mean(tf.square(style_gram - gen_gram))

 return total_loss

 def total_loss(self, content_image, style_image, generated_image,
 content_weight=1e4, style_weight=1e-2):
 # TODO: Комбинировать content и style losses
 pass

 def transfer_style(self, content_image, style_image, epochs=1000,
 content_weight=1e4, style_weight=1e-2):
 # TODO: Основной цикл оптимизации
 # 1. Инициализировать generated_image от content_image
 # 2. Создать переменную для оптимизации
 # 3. Цикл по epochs:
 # a. Вычислить losses
 # b. Вычислить градиент
 # c. Обновить изображение через optimizer
 # 4. Вернуть финальное изображение
 pass
# Что нужно дополнить:
# 1. Загрузку VGG19 и создание feature extractor
# 2. Реализацию Gram matrix
# 3. Content loss функцию
# 4. Style loss функцию
# 5. Основной цикл оптимизации с Adam optimizer
# 6. Визуализацию процесса применения стиля


2)Алгоритм работы НС по блокам:

3)Ответ на контрольный вопрос: 14. Объясните принцип работы алгоритма Minimax. Где он применяется?
Minimax — алгоритм принятия решений для игр с нулевой суммой (выигрыш одного = проигрыш другого). Его цель: выбрать ход, минимизирующий максимальный возможный проигрыш при оптимальной игре противника.
Как работает:
1.Строит дерево всех возможных ходов от текущей позиции до конечных состояний.
2.Чередует роли: MAX (наш игрок) — максимизирует свой выигрыш; MIN (противник) — минимизирует выигрыш MAX.
3.В конечных узлах присваивает значения: +1 (победа MAX), −1 (победа MIN), 0 (ничья).
4.Поднимает значения к корню: на уровнях MAX выбирается максимум из дочерних узлов; на уровнях MIN — минимум.
5.В корне выбирает ход с максимальным значением.
Где применяется: компьютерные игры: шахматы, шашки, крестики‑нолики; теория игр и экономика: моделирование переговоров, аукционов, рыночных стратегий; робототехника: планирование действий в конкурентной среде (например, движение в потоке); кибербезопасность: анализ атак и защит («игра» злоумышленник vs система); оптимизация: принятие решений в условиях неопределённости (сценарий «наихудшего случая»).
