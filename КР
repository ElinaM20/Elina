Алгоритмы сортировки

Блочная (корзинная) сортировка(bucket sort)
1) — это алгоритм, который распределяет элементы исходного массива на несколько блоков (корзин) в зависимости от диапазона их значений. После этого каждая корзина сортируется отдельно, и отсортированные корзины объединяются обратно в один массив.
2)Принцип работы:
1. Определяется количество корзин (например, по диапазону значений элементов).
    bucket_count = len(arr)  
    bucket_size = (max_val - min_val) / bucket_count  
2. Каждый элемент помещается в корзину согласно функции распределения.
    for num in arr:
3. Содержимое каждой корзины сортируется индивидуально
    for i in range(bucket_count):
3)Временная сложность:O(N+k), где: N — количество элементов, k — количество блоков (баков).
4)Почему: Если все элементы уже отсортированы и распределены равномерно. Поэтому каждый блок будет содержать одинаковое количество элементов. При этом создание сегментов заняло бы O(n), а сортировка вставки - O(k). Что дает временную сложность O(n + k)

Блинная сортировка(pancake sort)
1) — это метод, основанный на операции переворота (reversal) части массива. В отличие от большинства алгоритмов, которые обменивают соседние элементы или выбирают опорные точки, здесь единственная разрешённая операция — переворот префикса массива до выбранного индекса.
2)Принцип работы:
1. Найти максимальный элемент в неотсортированной части массива.
def find_max(arr, n):
2. Перевернуть подмассив от начала до позиции максимального элемента, чтобы этот элемент оказался первым.
def flip(arr, k):
3. Перевернуть весь подмассив, чтобы максимальный элемент оказался в конце.
def pancake_sort(arr):
4. Повторить процесс для оставшейся неотсортированной части массива.
3)Временная сложность: O(N^2), где N — количество элементов в массиве.
4)Почему:  алгоритм требует порядка n итераций для нахождения максимального элемента в неотсортированной части массива, и для каждой итерации может потребоваться до n переворотов.

Сортировка бусинами (гравитационная)(bead sort)
1)-сортировка, которая моделирует естественное поведение бусин, падающих вниз под действием гравитации.
2)Принцип работы:
1. Каждый элемент массива представляется в виде горизонтального ряда бусин, количество которых соответствует его значению.
beads_matrix = [[1 if num > row else 0 for col in range(max_num)] for row, num in enumerate(arr)]
2. Бусины располагаются на «стержнях» (как на абаке).
3. Под действием «гравитации» бусины падают вниз.
dropped_beads = [sorted(col, reverse=True) for col in transposed_beads] 
4. После оседания бусин строки считываются сверху вниз — получается отсортированный массив.
result = [sum(row) for row in zip(*dropped_beads)]
3)Временная сложность: O(M×N), где M — максимальный элемент в массиве, а N — количество элементов в массиве.
4)Почему: Для каждого элемента массива мы создаем строку в матрице, длина которой равна максимальному элементу(М). Каждый столбец матрицы должен быть отсортирован, что требует затрат порядка O(M) на каждый столбец. Поскольку столбцов N, общие затраты составляют O(M×N).
Алгоритмы поиска

Поиск скачками (Jump Search)
1) — это оптимизация линейного поиска для отсортированных массивов, при которой алгоритм «прыгает» через определённое число элементов (обычно через n), чтобы быстро сузить диапазон поиска, а затем выполняет линейный поиск внутри найденного диапазона.
2)Принцип работы:
1. Делится массив на блоки длины m=n.
block_length = n
2. Алгоритм прыгает вперёд на m элементов, пока не найдёт элемент, больше или равный искомому.
while next_pos < n and arr[next_pos] < target:
3. Если найденный элемент больше искомого, выполняется линейный поиск в предыдущем блоке.
for i in range(prev, min(next_pos, n)):
3)Временная сложность:O(√n), где n — длина массива.
4)Почему: мы прыгаем по массиву большими шагами, величина которых равна  √n, чтобы быстро сузить диапазон поиска, а затем выполняет линейный поиск внутри найденного диапазона.

Экспоненциальный поиск (Exponential Search)
1)- поиск, который сочетает идеи последовательного и бинарного поиска, позволяя быстро определить диапазон, в котором может находиться искомое значение, а затем применяет двоичный поиск в этом диапазоне.
2)Принцип работы:
1. Проверяется первый элемент массива.
if arr[0] == target:
2. Если элемент не найден, диапазон увеличивается экспоненциально: 1, 2, 4, 8, 16 и т.д., пока не будет найден элемент, больше или равный искомому.
while i < len(arr) and arr[i] <= target:
    i *= 2
3. На найденном диапазоне выполняется бинарный поиск.
from bisect import bisect_left
position = bisect_left(arr, target, low, high + 1)
3) Временная сложность:O(logN), где N — количество элементов в массиве.
4)Почему: Мы экспоненциально увеличиваем индекс (удваивая его на каждом шаге), пока не достигнем элемента, который больше или равен искомому. Это займет примерно logN шагов, так как на каждом шаге мы удваиваем индекс.

Тернарный поиск (Ternary Search)
1) — это метод деления диапазона поиска на три части (в отличие от двух в бинарном) и рекурсивного сужения диапазона до тех пор, пока не будет найден элемент или экстремум функции (в зависимости от задачи).
2)Принцип работы (для массива):
1. Делится диапазон индексов на три части.
third1 = left + (right - left) // 3
third2 = right - (right - left) // 3
2. Сравнивается искомый элемент с элементами на двух разделительных границах.
if arr[third1] == target:
    return third1
elif arr[third2] == target:
    return third2
3. Если совпадение не найдено, алгоритм повторяется рекурсивно в одной из трети массива, где может находиться искомое значение.
if target < arr[third1]:
elif target > arr[third2]:
3)Временная сложность:O(log3N), где N — количество элементов в массиве.
4)Почему: в каждом шаге рекурсивного тернарного поиска массив делится на три части, и дальнейший поиск выполняется в одной из них. Таким образом, на каждом шаге область поиска уменьшается втрое (оставляется одна треть от текущего диапазона).Поскольку на каждом шаге область поиска уменьшается втрое, количество шагов, необходимых для поиска, растёт логарифмически по основанию 3. 
