Алгоритмы сортировки

Блочная (корзинная) сортировка(bucket sort)
1) — это алгоритм, который распределяет элементы исходного массива на несколько блоков (корзин) в зависимости от диапазона их значений. После этого каждая корзина сортируется отдельно (либо тем же методом
рекурсивно, либо другим алгоритмом, например, вставками), и отсортированные корзины объединяются обратно в один массив.
2)Принцип работы:
1. Определяется количество корзин (например, по диапазону значений элементов).
    bucket_count = len(arr)  
    bucket_size = (max_val - min_val) / bucket_count  
2. Каждый элемент помещается в корзину согласно функции распределения.
    for num in arr:
3. Содержимое каждой корзины сортируется индивидуально
    for i in range(bucket_count):
3)Временная сложность:O(N+k), где: N — количество элементов, k — количество блоков (баков).
4)Почему: если входные данные равномерно распределены, то каждый блок будет содержать примерно одинаковое количество элементов. Тогда для сортировки каждого блока можно использовать встроенные эффективные алгоритмы (например, сортировка вставками или встроенная сортировка Python), которые имеют временную сложность O(K), где K — количество элементов в блоке.Обычно, количество блоков принимается равным количеству элементов (k ≈ N), тогда сортировка внутри блоков выполняется за время, близкое к O(1) (поскольку в каждом блоке примерно по одному элементу). Значит, суммарная временная сложность будет O(N+K)≈O(N+N)=O(N).

Блинная сортировка(pancake sort)
1) — это метод, основанный на операции переворота (reversal) части массива. В отличие от большинства алгоритмов, которые обменивают соседние элементы или выбирают опорные точки, здесь единственная разрешённая операция — переворот префикса массива до выбранного индекса.
2)Принцип работы:
1. Найти максимальный элемент в неотсортированной части массива.
def find_max(arr, n):
2. Перевернуть подмассив от начала до позиции максимального элемента, чтобы этот элемент оказался первым.
def flip(arr, k):
3. Перевернуть весь подмассив, чтобы максимальный элемент оказался в конце.
def pancake_sort(arr):
4. Повторить процесс для оставшейся неотсортированной части массива.
3)Временная сложность: O(N^2)
4)Почему: на каждом шаге мы переворачиваем массив дважды: один раз, чтобы поднять максимальный элемент наверх, и второй раз, чтобы поставить его на своё место. Это приводит к двум переворотам на каждой итерации. Для каждой итерации необходимо найти максимальный элемент в текущей рабочей части массива, что потребует дополнительного прохода по массиву. Эта операция выполняется на каждой итерации, а значит, суммарно мы проделываем эту операцию O(N) раз.

Сортировка бусинами (гравитационная)(bead sort)
1)-сортировка, которая моделирует естественное поведение бусин, падающих вниз под действием гравитации.
2)Принцип работы:
1. Каждый элемент массива представляется в виде горизонтального ряда бусин, количество которых соответствует его значению.
beads_matrix = [[1 if num > row else 0 for col in range(max_num)] for row, num in enumerate(arr)]
2. Бусины располагаются на «стержнях» (как на абаке).
3. Под действием «гравитации» бусины падают вниз.
dropped_beads = [sorted(col, reverse=True) for col in transposed_beads] 
4. После оседания бусин строки считываются сверху вниз — получается отсортированный массив.
result = [sum(row) for row in zip(*dropped_beads)]
3)Временная сложность: O(M×N), где M — максимальный элемент в массиве, а N — количество элементов в массиве.
4)Почему: Для каждого элемента массива мы создаем строку в матрице, длина которой равна максимальному элементу. Это занимает O(N×M) операций. Каждый столбец матрицы должен быть отсортирован, что требует затрат порядка O(M) на каждый столбец. Поскольку столбцов N, общие затраты составляют O(M×N). После поворота матрицы обратно и суммирования элементов, мы опять тратим O(N) операций на суммирование строк.

Алгоритмы поиска

Поиск скачками (Jump Search)
1) — это оптимизация линейного поиска для отсортированных массивов, при которой алгоритм «прыгает» через определённое число элементов (обычно через n), чтобы быстро сузить диапазон поиска, а затем выполняет линейный поиск внутри найденного диапазона.
2)Принцип работы:
1. Динамически выбираем величину шага (скачка), равную примерно квадратному корню из длины массива.
n = len(arr) 
step = int(math.sqrt(n))
2. Алгоритм прыгает вперёд на m элементов, пока не найдёт элемент, больше или равный искомому.
while arr[min(step, n) - 1] < target:
3. Если найденный элемент больше искомого, выполняется линейный поиск в предыдущем блоке.
while arr[prev] < target:
3)Временная сложность:O(sqrt(N)), где N — длина массива.
4)Почему: мы прыгаем по массиву большими шагами, величина которых равна sqrt(N). Количество таких крупных шагов в худшем случае составляет примерно sqrt(N).

Экспоненциальный поиск (Exponential Search)
1)- поиск, который сочетает идеи последовательного и бинарного поиска, позволяя быстро определить диапазон, в котором может находиться искомое значение, а затем применяет двоичный поиск в этом диапазоне.
2)Принцип работы:
1. Проверяется первый элемент массива.
if arr[0] == target:
2. Если элемент не найден, диапазон увеличивается экспоненциально: 1, 2, 4, 8, 16 и т.д., пока не будет найден элемент, больше или равный искомому.
while i < len(arr) and arr[i] <= target:
    i *= 2
3. На найденном диапазоне выполняется бинарный поиск.
from bisect import bisect_left
position = bisect_left(arr, target, low, high + 1)
3) Временная сложность:O(logN), где N — количество элементов в массиве.
4)Почему: Мы экспоненциально увеличиваем индекс (удваивая его на каждом шаге), пока не достигнем элемента, который больше или равен искомому. Это займет примерно logN шагов, так как на каждом шаге мы удваиваем индекс.
